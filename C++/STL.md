### STL常用容器:
vector, list, deque, set, map, multiset, multimap, stack, queue

### vector
- vector空间的增长/push_back操作
- vector比array的优点（动态数组）
- 操作效率
- 迭代器失效问题，注意重新分配内存的情况，会造成所有迭代器的失效
- vector 的特点：
  - 是一个线性顺序结构。可看作动态数组（空间可以动态扩展）。随机访问方便，它像数组一样被访问，即支持[ ]操作符和vector.at()；在内部进行插入、删除操作效率非常低.
- vector数组增长方式：
  - 首先预分配一个大小空间（capacity），够用不调整，不够用时：
    - 首先，vector 会申请一块更大的内存块（2*原来大小）；
    - 然后，将原来的数据拷贝到新的内存块中；
    - 其次，销毁掉原内存块中的对象（调用对象的析构函数）；
    - 最后，将原来的内存空间释放掉
- reserve(n) 预分配存储空间(capacity)
  - reserve(n): 预分配n个元素的存储空间
- vector中resize()和reserve()区别
  - 了解这两个函数的区别，首先要搞清楚容器的capacity（容量）与size（长度）的区别。
    - size指容器当前拥有的元素个数；
    - 而capacity则指容器在必须分配新存储空间之前可以存储的元素总数。也可以说是预分配存储空间的大小。
  - resize()函数和容器的size息息相关。调用resize(n)后，容器的size即为n。至于是否影响capacity，取决于调整后的容器的size是否大于capacity。
  - reserve()函数和容器的capacity息息相关。调用reserve(n)后，若容器的capacity<n，则重新分配内存空间，从而使得capacity等于n。如果capacity>=n,capacity无变化。
  - 从两个函数的用途可以发现，容器调用resize()函数后，所有的空间都已经初始化了，所以可以直接访问。而reserve()函数预分配出的空间没有被初始化，所以不可访问。
  - 一个简单的测试用例:
  ```
  vector<int> a;  
  a.reserve(100);  
  a.resize(50);  
  cout<<a.size()<<"  "<<a.capacity()<<endl;  // 50 100
  a.resize(150);  
  cout<<a.size()<<"  "<<a.capacity()<<endl;  // 150 150
  a.reserve(50);  
  cout<<a.size()<<"  "<<a.capacity()<<endl;  // 150 150
  a.resize(50);  
  cout<<a.size()<<"  "<<a.capacity()<<endl;  // 50 150
  ```
  
### list
- 双向（环状）循环列表
- 迭代器只需要一个指针，迭代器的移动是链表节点的移动
- 操作效率

### deque
- 双端开口不连续数组
- 数组 + 映射连接
- 操作效率：介于vector和list之间
- 空间增长不会像vector那样完全重新分配

### 红黑树
- 5个性质
- 红黑树和AVL树有什么区别吗？
  - AVL树是严格的自平衡二叉查找树。在AVL树中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树。
  - 红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树是牺牲了严格的高度平衡的优越条件为代价来提高性能。
- 节点结构
- 元素操作：插入删除，BST, 旋转和颜色改变
- 两种插入方式：insert_unique()， insert_equal()

### set
- set特性
  - 底层：红黑树
  - 元素自动排序（红黑树性质，BST）
  - 键值不能重复
- 不能通过set的迭代器改变set的元素值
- set迭代器失效问题
- 操作效率: O(log(n))
- set底层使用红黑树的原因

### map
- map特性
  - 底层：红黑树
  - 元素自动排序（红黑树性质，BST）
  - 键值不能重复
- 不能通过map的迭代器改变map的键值，但可以改变实值
- map迭代器失效问题
- 操作效率: O(log(n))
- map底层使用红黑树的原因
- map的insert()函数和subscribe(下标)操作符
  - insert()函数: 返回pair<iterator, bool>
  - subscribe(下标)操作符: 既可以是左值，也可以是右值(原因：返回值采用引用的方式)

### multiset， multimap：
- 允许值重复

### vector，list，deque的区别
- vector:
  - 指定一块如同数组一样的连续存储，但空间可以动态扩展。即它可以像数组一样操作，并且可以进行动态操作([])。通常体现在push_back() pop_back()
  - 随机访问方便，它像数组一样被访问，即支持[ ]操作符和 vector.at()
  - 在内部进行插入、删除操作效率非常低（O(n)）
  - 当动态添加的数据超过vector 默认分配的大小时要进行内存的重新分配、拷贝与释放，这个操作非常消耗性能。 所以要vector 达到最优的性能，最好在创建vector时就指定其空间大小。
- list：
  - 双向线性链表结构
  - 不使用连续的内存空间这样可以随意地进行动态操作
- list 随机检索的性能非常的不好，检索需要顺序遍历（O(n)）
  - 可以迅速地在任何节点进行插入和删除操作,当然也可以在两端进行push 和pop。(O(1))
- deque
  - 双端队列
  - 一种优化了的、对序列两端元素进行添加和删除操作的基本序列容器
  - deque 是对vector 和list 优缺点的结合，它是处于两者之间的一种容器。它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。向deque 两端添加或删除元素的开销很小。它不需要重新分配空间，所以向末端增加元素比vector 更有效
- 小结：
  - 在存储结构上，vector 是一段连续的内存块，而deque 是多个连续的内存块， list 是所有数据元素分开保存，可以是任何两个元素没有连续
   操作效率上：
    - vector 的查询性能最好，并且在末端增加数据也很好，除非它重新申请内存段；适合高效地随机存储。
    - list 是一个链表，任何一个元素都可以是不连续的，但它都有两个指向上一元素和下一元素的指针。所以它对插入、删除元素性能是最好的，而查询性能非常差；适合 大量地插入和删除操作而不关心随机存取的需求。
    - deque 是介于两者之间，它兼顾了数组和链表的优点，它是分块的链表和多个数组的联合。所以它有比list 好的查询性能，有比vector 好的插入、删除性能。 如果你需要随机存取又关心两端数据的插入和删除，那么deque 是最佳之选。

### 迭代器失效问题
- 迭代器（iterator）是一个可以对其执行类似指针的操作（如：解除引用（operator*()）和递增（operator++()））的对象，我们可以将它理解成为一个指针。
- vector迭代器的几种失效的情况： 
  - 当插入（push_back）一个元素后，end操作返回的迭代器肯定失效。
  - 当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效。
  - 当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。
  - 对于顺序式容器(vector)元素的删除、插入操作会导致指向该元素以及后面的元素的迭代器失效
- deque迭代器的失效情况：
  - 在deque容器首部或者尾部插入元素不会使得任何迭代器失效。 
  - 在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。
  - 在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。
- 节点式容器(map, list, set)迭代器的失效情况:
  - 元素的删除，插入操作会导致指向该元素的迭代器失效，其他元素迭代器不受影响
  - 当使用一个容器的insert或者erase函数通过迭代器插入或删除元素"可能"会导致迭代器失效，因此很多建议都是让我们获取insert或者erase返回的迭代器，以便用重新获取新的有效的迭代器进行正确的操作： 
  ```
  iter = vec.insert(iter);  
  iter = vec.erase(iter);  
  ```

### 红黑树：
- 基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。
- 它是二叉排序树（继承二叉排序树特显）：
    - 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。
    - 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。
    - 左、右子树也分别为二叉排序树。
- 它满足如下几点要求：
    - 树中所有节点非红即黑。
    - 根节点必为黑节点。
    - 红节点的子节点必为黑（黑节点子节点可为黑）。
    - 从根到NULL的任何路径上黑结点数相同。
- 查找时间一定可以控制在O(logn)。
- 所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。
- 相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。
- 从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列......最长路径不会大于2n，这里路径长就是树高。

### 当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？
- vector内存用完了，会以当前size大小重新申请2*size的内存，然后把原来的元素复制过去，把新元素插上，然后释放原来的内存。
- vector的内存释放：http://www.cnblogs.com/summerRQ/articles/2407974.html
- 一般我们释放vector里的元素使用clear，其实它不能释放内存，要想释放内存要使用swap，这样：
```
vector<type> v;
//.... 这里添加许多元素给v
//.... 这里删除v中的许多元素
vector<type>(v).swap(v);
//此时v的容量已经尽可能的符合其当前包含的元素数量
//对于string则可能像下面这样
string(s).swap(s);
```
- 引用《effective stl》的第十二条：当涉及 STL容器和线程安全性时，你可以指望一个 STL库允许多个线程同时读一个容器，以及多个线程对不同的容器做写入操作。你不能指望 STL库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。必须自己去写多线程安全措施。

### map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？
- 红黑树和散列
- O(logn)
- 不可以，map不像vector，它在对容器执行erase操作后不会返回后一个元素的迭代器，所以不能遍历地往后删除。

### stack
- stack不允许有遍历行为，没有迭代器
- 底层实现：deque(默认), list

### queue
- queue不允许有遍历行为, 没有迭代器
- 底层实现：deque(默认), list

### heap
- 完全二叉树
- 堆的调整
- 建堆
- 堆排序
- 底层实现： vector
- 最小堆和最大堆
- 在堆中插入元素：
  - 将新元素放在vector的末尾， 进行上溯
- 向堆中删除元素：
  - 将堆顶元素与最末尾元素调换，再进行下溯
- 堆排序算法

### priority_queue
- 实现：最大堆

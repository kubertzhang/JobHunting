本节部分内容搬运自 https://github.com/linw7/Skill-Tree

#### C++和Java的区别？
- `Java`不再支持指针。这可能是`C++`和`Java`之间的最大不同
- `Java`和`C++`都是面向对象语言（封装性，继承性，多态性）。但`C++`兼容了`C`，可以当做带类的`C`语言来使用；`Java`则是完全的面向对象语言
- `Java`属于解释型语言，而`C++`属于编译型语言，所以一般来讲`C++`的运行速度要比`Java`快

#### 宏定义(define)和const区别？
- 编译时间：宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
- 类型检查：宏不检查类型；const会检查数据类型。
- 分配空间：宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

#### 宏定义和函数有何区别？
- 宏替换发生在编译阶段之前，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏函数不要在最后加分号。

#### 宏定义和typedef区别？
- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
- 宏不检查类型；typedef会检查数据类型。
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，`typedef char * p_char`和`#define p_char char *`区别巨大。typedef是定义了一种类型的新别名；宏是单纯的字符串替换。
`typedef char* PSTR; const PSTR;`实际上相当于`const char*`吗？NO，它实际上相当于`char* const`。原因在于`const`给予整个指针本身以常量性，也就是形成了常量指针`char* const`。

#### 宏定义和内联函数(inline)区别？
- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
- 内联函数本身是函数，强调函数特性，具有重载等功能。
- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

#### 指针和引用区别？
- 存储空间：引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。
- 引用在声明时必须初始化为另一变量，一旦出现必须为``typename refname &varname``的形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

#### new,delete和malloc，free的区别
- malloc/free是C++/C语言的标准库文件函数；new/delete是C++的运算符；
- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- malloc分配内存空间前需要计算分配内存大小；而new能够自动分配内存空间。
- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。
- malloc函数类型不是安全的，编译器不对其进行类型转换、类型安全的相关检查。malloc申请空间后，不会对其初始化，要单独初始化；而new类型是安全的，因为它内置了sizeof、类型转换和类型安全检查功能，且在创建对象时，就完成了初始化工作，一般初始化调用无参构造函数；

#### 变量声明和定义区别？
- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
- 相同变量可以再多处声明（外部变量extern），但只能在一处定义。

#### 零值比较？
    - bool类型：if(flag)
    - int类型：if(flag == 0)
    - 指针类型：if(flag == NULL)
    - float类型：if((flag >= -0.000001) && (flag <= 0. 000001))

#### strlen和sizeof区别？
- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数，结果在运行时得到
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。
注：sizeof()的参数如果是指针的话，得到的是指针变量的大小（一般为4字节）

详细：https://www.cnblogs.com/carekee/articles/1630789.html

#### sizeof返回的值表示的含义？
- 数组——编译时分配的数组空间大小；
- 指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
- 类型——该类型所占的空间大小；
- 对象——对象的实际占用空间大小；
- 函数——函数的返回类型所占的空间大小。函数的返回类型不能是void

#### static作用是什么？在C和C++中有何区别？
- static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。
- C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。
- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
- 未初始化时，static变量默认值为0。

#### 结构体和类的区别？
- 结构体的默认限定符是public；类是private
- 结构体的默认继承是公有继承(public), 类的默认继承是私有继承(private)

#### 条件编译#ifdef, #else, #endif作用？
- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。
- 用于子程序前加#define DEBUG用于程序调试。
- 应对硬件的设置（机器类型等）。
- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。

#### const 与指针
```
const int a;
int const a;
const int *a;
int *const a;
```
- ``int const a``和``const int a``均表示定义常量类型``a``。
- ``const int *a``：指向常量的指针变量 -- const 修饰 int *a 指向的值
```
int a=0, b=1;
const int *p;    // 声明常量指针p
p=&a;             // p指向a
p=&b;             // 修改指针p让其指向b，允许
*p=2;              // 不允许（指向常量的指针变量， 不能通过指针改变指向常量的值）
 ```
- ``int *const a``：指向变量的指针常量 -- int * 定义指针，而指针是const的
```
int a=0,b=1;
int *const p1=&a;      // 必须在定义的时候进行初始化
int *const p2;            // 不允许，必须对其初始化
p2=&b;                     // 不允许，p2是常量不允许作为左值
*p1=2;                      // 允许通过指针修改指针指向的值
```
    
#### volatile有什么作用
- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
- 多线程中被几个任务共享的变量需要定义为volatile类型。

#### 什么是常引用？
- 常引用可以理解为常量指针，形式为`const typename & refname = varname`。
- 常引用下，原变量值不会被别名所修改。
- 原变量的值可以通过原名修改。
- 常引用通常用作只读变量别名或是形参传递。

#### 区别以下指针类型？
```
int *p[10];
int (*p)[10];
int *p(int);
int (*p)(int);
```
- `int *p[10]`表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。表示一个多维数组
- `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10（指针加减时移动单位是整个数组大小）。
- `int* p(int)`是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- `int (*p)()`是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

参考：https://stackoverflow.com/questions/24104482/difference-between-pointer-to-an-array-and-pointer-to-the-first-element-of-an-ar
    
技巧：“先右后左”，向右划分完后，将整体作为一个返回符号，再分析向左的情况
    
#### a和&a有什么区别？
假设数组
```
int a[10];
int (*p)[10] = &a;
```
- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
- &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

技巧：明确指针指向的内存块的大小
    
#### 数组名和指针（这里为指向数组首元素的指针）区别？
- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

#### 堆和栈的区别？
- 申请方式不同。
    - 栈由系统自动分配。
    - 堆由程序员手动分配。
- 申请大小限制不同。
    - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
    - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
    - 栈由系统分配，速度快，不会有碎片。
    - 堆由程序员分配，速度慢，且会有碎片。

#### delete和delete[]区别？
- delete只会调用一次析构函数。
- delete[]会调用数组中每个元素的析构函数。

#### extern关键字作用？
- extern声明变量和函数在外部定义
当它不与"C"在一起修饰变量或函数时，如在头文件中，extern int g_nNum;，它的作用就是声明函数或变量的作用范围的关键字，其声明的函数和变量可以在本编译单元或其他编译单元中使用。
- extern C 的作用？
当它与"C"一起连用时，如: `extern "C" void fun(int a, int b);`则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的
- extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。

#### const有什么用途?
- 定义只读变量，即常量 
- 修饰函数的参数和函数的返回值为只读变量
- 修饰函数的定义体，这里的函数为类的成员函数，被const修饰的成员函数代表不修改成员变量的值

#### c++ 11 新特性?
- long long 类型 
- 列表初始化
- nullptr
- auto 类型指示符
- 范围for语句
- 智能指针
- ...

具体内容见《C++ Primer》

#### 函数参数形参？
- 值传递（复制）
- 指针（可能修改形参）
- 引用（可能修改形参）

#### `const vector<Type>`和`vector<const Type>`的区别？
- `const vector<Type>`：由于vector是一个容器类，const 修饰的其实是vector；`const vector<int>::iterator`中，const是修饰的迭代器，也就是是个常迭代器，不能做左值，进行自加自减操作，但可通过迭代器来访问和修改元素的值。
```
const vector<int> ivec(10,10);  
ivec[0] = 1;  //报错
```
const vector调用operator[]成员函数时调用的只能是const版本的那个函数，此函数返回的也是一个const reference，即此处返回的是一个const int。 

这并不意味着vector内部的内容不可改变，而是方法不对。我们通过通过vector的iterator迭代指针来完成值的改变。
- `vector<const Type>`：
```
vector<const int> ivec2(10, 10);//通过  
ivec2[0] = 1; //通过  
```
可以发现编译器把`vector<const int>`当做`vector<int>`处理

#### const vector <int> ::iterator和vector <int>::const_iterator有什么不同?
按照类似const 和指针的关系来区别：
- `const vector <int> ::iterator` --> `int * const p`: 指向变量的指针常量
- `vector <int>::const_iterator` --> `const int *p`: 指向常量的指针变量

类似于指针，`const vector<int>::iterator`中，const是修饰的迭代器，也就是是个常迭代器，一旦初始化比如`=a.begin()`，再不能更改它的值，比如赋值`=a.end()`是不行的，递增递减操作等都不允许。

虽然类似指针，但指针是内置类型，所以编译器可以通过const的位置来判断是常指针还是指向常量的指针，而迭代器只是一个对象，所以编译器不能分辨，所以用const_iterator来取代指向常量的指针，使用它，你通过这个迭代器对迭代器所指向的内容进行改写是非法的。

通过简单的代码区别,更能说明问题:
```
vector<int> ivec;
vector<int>::const_iterator citer1 = ivec.begin();
const vector<int>::iterator citer2 = ivec.begin();
*citer1 = 1;    //error
*citer2 = 1;    //right
++citer1;       //right
++citer2;       //error
```

#### struct和union的区别?
- 关键区别在于内存单元的分配和使用
- 在存储多个成员信息时，编译器会自动给struct每个成员分配存储空间，struct 可以存储多个成员信息；而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息
- 都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。
- 对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的
- struct 简单来说就是一些相互关联的元素的集合。元素在内存中的存放是按你声明的变量顺序来存放的
- 元素的相关性不强时，完全可以使用union，从而节省内存size； struct和union还可以相互嵌套

#### 内存对齐方式
- 复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。
- 分配给union的内存size 由类型最大的元素 size 来确定
- 32的`C++`采用8位对界来提高运行速度。对界是可以更改的，使用#pragma pack(x)宏可以改变编译器的对界方式，默认是8
- `C++`固有类型的对界取编译器对界方式与自身大小中较小的一个，但需满足各个成员对其大小的整数倍关系

参考：http://blog.csdn.net/firefly_2002/article/details/7954458

#### 结构体内存对齐问题？
- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）。
- 如果用宏指定对界大小的话，取对界和size最小成员中的较小值对齐

#### C++ 值传递、指针传递、引用传递详解？
- 指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）
- 而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
- 引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

参考：https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html

#### open函数和fopen函数区别?
- 前者属于低级IO，后者是高级IO。
- 前者返回一个文件描述符(用户程序区的)，后者返回一个文件指针。
- 前者无缓冲，后者有缓冲。
- 前者与 read, write 等配合使用， 后者与 fread, fwrite等配合使用。
- 后者是在前者的基础上扩充而来的，在大多数情况下，用后者。
- fopen和open最主要的区别是fopen在用户态下就有了缓存，在进行read和write的时候减少了用户态和内核态的切换，而open则每次都需要进行内核态和用户态的切换；表现为，如果顺序访问文件，fopen系列的函数要比直接调用open系列快；如果随机访问文件open要比fopen快。

参考：https://www.cnblogs.com/joeblackzqq/archive/2011/04/11/2013010.html

#### 实现strlen？
```
int strlen(const char *str)
{
	if ('\0' == *str)
		return 0;
	return strlen(str + 1) + 1;
}
```

参考：https://blog.csdn.net/tianmohust/article/details/6667111

#### strcpy和strncpy用法和区别？
- strcpy函数：
    - 顾名思义字符串复制函数
    - 原型：`extern char *strcpy(char *dest,char *src); `
    - 功能：把从src地址开始且含有NULL结束符的字符串赋值到以dest开始的地址空间，返回dest（地址中存储的为复制后的新值）。
    - 要求：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。
    - 该函数的参数是字符指针，也就是可以是字符串变量和字符数组，因为它们的变量名代表首字符地址。字符串默认有一个null结束符，字符数组没有。所以此处需要注意：因为src要求有null结束符，所以字符数组的长度必须大于等于src包含null结束符的总长度。例如，`char* src="abcd"; char dest[5];`这里dest的长度就至少为5。
- strncpy函数：
    - 多个n代表可以指定字符个数进行赋值。
    - 原型：char * strncpy(char *dest, char *src, size_t n);  
    - 功能：将字符串src中最多n个字符复制到字符数组dest中(它并不像strcpy一样遇到NULL才停止复制，而是等凑够n个字符才开始复制），返回指向dest的指针。要求：如果n > dest串长度，dest栈空间溢出产生崩溃异常。该函数注意的地方和strcpy类似，但是n值需特别注意
- 两个的安全性：
    - strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。 
    - strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。 
    - 建议使用方式：
    ```
    strncpy(dest, src, sizeof(dest));   // 重点在sizeof(dest)   == 用n来指定要复制的长度
    dest[sizeof(dest)-1] =’\0’; 
    ```
    - 在安全性方面，显然strncpy要比strcpy安全得多，strcpy无法控制拷贝的长度，不小心就会出现dest的大小无法容纳src的情况，就会出现越界的问题，程序就会崩溃。而strncpy就控制了拷贝的字符数避免了这类问题，但是要注意的是dest依然要注意要有足够的空间存放src，而且src 和 dest 所指的内存区域不能重叠

参考：

https://blog.csdn.net/MBuger/article/details/52247932

https://www.cnblogs.com/xmxu/archive/2012/08/20/2647382.html
